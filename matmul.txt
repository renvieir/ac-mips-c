; multiplicacao de matrizes

        .data
; Ordem da matriz (mude este valor para 1..4)
N:      .word32 4

; Matrizes A e B armazenadas COLUMNWISE (coluna por coluna).
; Ex.: coluna 0 inteira, depois coluna 1, etc.
; A (4x4) exemplo
A:      .word32 1,5,9, 13    ; coluna 0: A(0,0),A(1,0),A(2,0),A(3,0)
        .word32 2,6,10,14    ; coluna 1
        .word32 3,7,11,15    ; coluna 2
        .word32 4,8,12,16    ; coluna 3

; B (4x4) exemplo
B:      .word32 1, 2, 3, 4
        .word32 5, 6, 7, 8
        .word32 9, 10,11,12
        .word32 13,14,15,16

; Espaço para resultado C (inicializado com zeros), também columnwise
C:      .word32 0:16

; strings para impressao (se desejar um separador entre números)
newline: .asciiz "\n"
space:   .asciiz " "

        .text
        .globl main
main:
; ------------------------------------------------------------
; Prologue / Convenção: carregar bases e N em registradores $s*
; s0 = &A, s1 = &B, s2 = &C, s3 = N
; s4 = i (row index), s5 = j (col index), s6 = k (inner)
; t-registers usados para temporários
; ------------------------------------------------------------
        la      $s0, A          ; base A
        la      $s1, B          ; base B
        la      $s2, C          ; base C
        lw      $s3, N          ; N

        ; precomputar strideA = 4 * N (bytes to advance A pointer when k++)
        sll     $t8, $s3, 2     ; t8 = 4 * N

        li      $s4, 0          ; i = 0 (row)
outer_i:
        li      $s5, 0          # j = 0 (col)
outer_j:
        # --- Preparação para calcular C(i,j) ---
        # t3 = i * 4  (offset for row within a column)
        sll     $t3, $s4, 2

        # A_ptr = A_base + i*4   (points to A(i, k=0))
        add     $t1, $s0, $t3

        # B_ptr = B_base + (j * N)*4  => compute j*N then *4
        mul     $t4, $s5, $s3    # t4 = j * N
        sll     $t4, $t4, 2      # t4 = 4 * j * N
        add     $t2, $s1, $t4    # t2 = &B(0,j)

        # accumulator = 0
        li      $t0, 0

        # k = 0
        li      $s6, 0
inner_k:
        # load A(i,k)  -> at t1
        lw      $t5, 0($t1)
        # load B(k,j)  -> at t2
        lw      $t6, 0($t2)
        # multiply and accumulate
        mul     $t7, $t5, $t6
        add     $t0, $t0, $t7

        # advance pointers for next k:
        # A_ptr += 4*N  (go to next column, same row)
        add     $t1, $t1, $t8
        # B_ptr += 4    (next row inside same column)
        addi    $t2, $t2, 4

        addi    $s6, $s6, 1
        blt     $s6, $s3, inner_k

        # --- armazenar resultado C(i,j)
        # compute offset: (j * N + i) * 4
        mul     $t4, $s5, $s3    # t4 = j * N
        add     $t4, $t4, $s4    # t4 = j*N + i
        sll     $t4, $t4, 2      # bytes offset
        add     $t9, $s2, $t4    # t9 = &C(i,j)
        sw      $t0, 0($t9)

        # próxima coluna j++
        addi    $s5, $s5, 1
        blt     $s5, $s3, outer_j

        # próxima linha i++
        addi    $s4, $s4, 1
        blt     $s4, $s3, outer_i

        # -------------------------------------------------
        # Impressão da matriz C em ordem ocidental:
        # Percorre linhas 0..N-1 e colunas 0..N-1 e carrega C(i,j)
        # lembrando armazenamento columnwise (endereço = base + 4*(j*N + i))
        # -------------------------------------------------
        li      $s4, 0          # i = 0
print_row:
        li      $s5, 0          # j = 0
print_col:
        # compute addr = C + 4*(j*N + i)
        mul     $t4, $s5, $s3
        add     $t4, $t4, $s4
        sll     $t4, $t4, 2
        add     $t9, $s2, $t4
        lw      $t0, 0($t9)

        # print integer (syscall)
        move    $a0, $t0
        li      $v0, 1
        syscall

        # print space
        la      $a0, space
        li      $v0, 4
        syscall

        addi    $s5, $s5, 1
        blt     $s5, $s3, print_col

        # print newline
        la      $a0, newline
        li      $v0, 4
        syscall

        addi    $s4, $s4, 1
        blt     $s4, $s3, print_row

        # exit
        li      $v0, 10
        syscall