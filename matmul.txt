.data
    ; Matriz A (2x2) armazenada columnwise:
    ; A = [ 1  3
    ;       2  4 ]
A:      .word32 1, 2
        .word32 3, 4

    ; Matriz B (2x2) armazenada columnwise:
B:      .word32 5, 6
        .word32 7, 8

    ; strings e bloco de parametros para syscall 5
fmt_res:    .asciiz "resultado [%i %i]\n"
params5:    .space 12    ; [ptr_format (4)][int1 (4)][int2 (4)]

.text
.globl main
main:
    ; carregar A(0,0) e A(0,1) diretamente em a0,a2
    lui     $t0, %hi(A)
    addi    $t0, $t0, %lo(A)
    lw      $a0, 0($t0)      ; A(0,0)
    lw      $a2, 8($t0)      ; A(0,1)  (offset 2 words = 8 bytes)

    ; carregar B(0,0) e B(0,1) diretamente em a1,a3
    lui     $t1, %hi(B)
    addi    $t1, $t1, %lo(B)
    lw      $a1, 0($t1)      ; B(0,0)
    lw      $a3, 8($t1)      ; B(0,1)

    ; chamar funcao que calcula os dois produtos (a0*a1, a2*a3)
    jal     prod_esc

    ; resultado: v0 = produto1, v1 = produto2
    ; montar bloco params5: [ptr_format][produto1][produto2]
    lui     $t2, %hi(fmt_res)
    addi    $t2, $t2, %lo(fmt_res)
    lui     $t3, %hi(params5)
    addi    $t3, $t3, %lo(params5)

    sw      $t2, 0($t3)      ; params5[0] = &fmt_res
    sw      $v0, 4($t3)      ; params5[1] = produto1
    sw      $v1, 8($t3)      ; params5[2] = produto2

    ; chamar syscall 5 (print formatted) passando &params5 em a0
    move    $a0, $t3
    li      $v0, 5
    syscall

    ; exit via syscall 0
    li      $v0, 0
    syscall

; --------------------------------------------------
; prod_esc: argumentos: a0,a1,a2,a3
; retorna: v0 = a0*a1, v1 = a2*a3
; preserva $s0 (exemplo de convenção)
; --------------------------------------------------
prod_esc:
    addi    $sp, $sp, -8
    sw      $s0, 4($sp)
    sw      $ra, 0($sp)

    mult    $a0, $a1
    mflo    $t0
    mult    $a2, $a3
    mflo    $t1

    move    $v0, $t0
    move    $v1, $t1

    lw      $ra, 0($sp)
    lw      $s0, 4($sp)
    addi    $sp, $sp, 8
    jr      $ra
